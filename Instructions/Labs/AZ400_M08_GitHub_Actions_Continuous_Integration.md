---
lab:
    title: '랩: GitHub Actions 연속 통합'
    module: '모듈 8: GitHub Actions를 사용하여 연속 통합 구현'
---

# 랩: GitHub Actions 연속 통합
# 학생 랩 매뉴얼

## 랩 개요

GitHub Actions를 활용하면 GitHub 리포지토리에 CI(연속 통합)를 통합하는 과정을 간편하게 진행할 수 있습니다. 이 랩에서는 빌드 프로세스를 자동화하는 GitHub 워크플로 2개를 설정합니다.

> **참고**: 이 랩에서는 개별 랩 작업을 안내하는 **github-learning-lab** 봇과의 상호 작용을 진행하게 됩니다.

## 목표

이 랩을 완료하면 다음 작업을 수행할 수 있습니다.

- 연속 통합 과정에서 GitHub Actions의 중요성 설명
- 템플릿 기반 워크플로 사용 및 사용자 지정
- 팀의 요구 및 행동 방식과 일치하는 CI 워크플로 만들기
- 워크플로의 모든 작업에서 리포지토리 소스 코드 및 빌드 아티팩트 사용
- GitHub Actions를 사용하여 단위 테스트 프레임워크 구현
- 테스트를 실행하고 테스트 보고서를 생성하는 워크플로 만들기
- 행렬형 빌드를 설정하여 여러 대상 플랫폼용 빌드 아티팩트 만들기
- 리포지토리 빌드 아티팩트 저장 및 액세스
- 애플리케이션 CI 요구에 맞는 가상 환경 선택

> **참고**: 이 랩에서 수행하는 대부분의 작업은 빌드와 관련된 작업입니다. 이러한 빌드를 작성하려면 몇 분 정도 걸릴 수도 있습니다. 빌드가 완료될 때까지 기다린 후에 다음 단계로 넘어가세요.

## 랩 소요 시간

-   예상 시간: **150분**

## 지침

### 시작하기 전

#### 랩 가상 머신에 로그인

다음 자격 증명을 사용하여 Windows 10 컴퓨터에 로그인했는지 확인합니다.
    
-   사용자 이름: **Student**
-   암호: **Pa55w.rd**

#### 이 랩에 필요한 애플리케이션 검토

이 랩에서 사용할 애플리케이션을 확인합니다.
    
-   Microsoft Edge

#### GitHub 계정 설정

이 랩에 사용할 수 있는 GitHub 계정이 아직 없으면 [새 GitHub 계정 등록](https://docs.github.com/en/free-pro-team@latest/github/getting-started-with-github/signing-up-for-a-new-github-account)에서 제공되는 지침에 따르세요.

### 연습 1: GitHub Actions를 사용하여 연속 통합 구현

이 연습에서는 GitHub Actions를 사용하여 연속 통합을 구현합니다.

#### 작업 1: GitHub 리포지토리에 템플릿 기반 워크플로 추가

이 작업에서는 다음의 단계를 순서대로 진행하여 템플릿 기반 워크플로를 사용해 끌어오기 요청을 만듭니다.

- 작업 탭으로 이동합니다.
- 템플릿 Node.js 워크플로를 선택합니다.
- 새 분기로 워크플로를 커밋합니다.
- 제목이 Node용 CI인 끌어오기 요청을 만듭니다.

1.  랩 컴퓨터에서 웹 브라우저를 시작하고 [GitHub Actions: 연속 통합 랩](https://lab.github.com/githubtraining/github-actions:-continuous-integration)의 시작 페이지로 이동합니다. GitHub에 아직 로그인하지 않았다면 오른쪽 위에서 **로그인**을 클릭합니다.
1.  **GitHub 학습 랩** 페이지에서 **GitHub 학습 랩을 사용하여 학습 시작**을 클릭합니다. 
1.  [GitHub Actions: 연속 통합 랩](https://lab.github.com/githubtraining/github-actions:-continuous-integration)의 시작 페이지로 돌아와서 **무료 교육 과정 시작**을 클릭합니다.
1.  **GitHub 학습 랩**에서 GitHub 계정에 공용 리포지토리 **github-actions-for-ci**를 만든다는 메시지가 포함된 팝업 창이 표시됩니다. 해당 메시지를 확인하고 **GitHub Actions 시작: 연속 통합**을 클릭합니다.
1.  **GitHub Actions: 연속 통합** 페이지의 시작 페이지로 돌아와서 **교육 과정 단계** 목록에서 첫 번째 단계인 **템플릿 기반 워크플로 사용** 옆의 **시작**을 클릭합니다. 그러면 **github-actions-for-ci** 리포지토리의 **문제** 탭으로 자동 리디렉션됩니다.
1.  **github-actions-for-ci** 리포지토리의 **문제** 탭 **버그 있음** 문제 페이지에서 **시작** 섹션의 내용을 검토합니다. 

    > **참고**: **시작** 섹션의 내용에 따르면 해당 리포지토리에는 버그가 있습니다. 여기서는 이러한 시나리오를 더욱 쉽게 검색, 진단 및 최소화할 수 있도록 CI(연속 통합) 사례를 사용하여 자동화된 테스트를 설정합니다. 코드베이스는 Node.js로 작성되어 있습니다. GitHub Actions에서는 Node.js와 같이 일반적으로 사용되는 언어 및 프레임워크에 몇 가지 템플릿 기반 워크플로를 사용할 수 있습니다. 여기서는 템플릿 기반 워크플로를 사용하여 끌어오기 요청을 만듭니다.

1.  **버그 있음** 페이지에서 상단 메뉴 탭 머리글 **작업**을 클릭합니다. 
1.  **github-actions-for-ci** 리포지토리 **작업** 탭의 **GitHub Actions 시작하기** 페이지에 있는 **Node.js** 창에서 **이 워크플로 설정**을 클릭합니다.
1.  **github-actions-for-ci/.github/workflows/node.js.yml** 페이지에서 **커밋 시작**을 클릭합니다.
1.  **새 파일 커밋** 창에서 기본 설정을 그대로 적용합니다. 그러면 이 커밋용으로 새 분기가 작성되며 끌어오기 요청이 시작됩니다. **새 파일 커밋**을 클릭합니다.
1.  **끌어오기 요청 열기** **node.js.yml 만들기** 페이지에서 끌어오기 요청 이름을 **node.js.yml 만들기**를 **Node용 CI**로 바꾸고 **끌어오기 요청 만들기**를 클릭합니다.

> **참고**: 분기에 템플릿 기반 워크플로만 추가해도 GitHub Actions에서 리포지토리 대상 CI를 시작할 수 있습니다. 

#### 작업 2: 템플릿 기반 워크플로 실행

이 작업에서는 템플릿 기반 워크플로 실행을 추적하고 결과를 검토합니다.

1.  **github-actions-for-ci** GitHub 리포지토리의 **Node용 CI 2** 페이지 **끌어오기 요청** 탭에 있는 해당 끌어오기 요청의 **대화** 탭에서 해당 요청의 변경 내용(**github/workflows/node.js.yml** 파일의 내용)을 검토합니다.
1.  개별 변경 내용을 검토한 후 해당하는 **대화 확인** 단추를 클릭합니다.

    > **참고**: **github/workflows/node.js.yml** 파일에는 다음 구성 요소가 포함되어 있습니다.

    - 워크플로: 자동화 단위인 워크플로에는 자동화를 트리거하는 항목의 정의, 자동화 중에 고려해야 하는 환경이나 기타 측면, 그리고 트리거 결과로 수행되어야 하는 작업이 포함됩니다.
    - 작업: 작업은 단계 하나 이상으로 구성된 워크플로의 섹션입니다. 샘플 워크플로에서는 템플릿이 빌드 작업 내의 단계를 정의합니다.
    - 단계: 자동화 과정의 한 부분을 나타내는 단계는 GitHub 작업으로 정의할 수 있습니다.
    - 작업: GitHub 작업은 워크플로와 호환되는 방식으로 작성된 자동화의 한 부분입니다. GitHub에서 바로 제공되거나 오픈 소스 커뮤니티에서 제공되는 기본 제공 작업을 사용할 수도 있고 사용자 지정 작업을 만들 수도 있습니다. 예를 들어 **actions/checkout@v2**는 빌드를 실행 중인 가상 머신에 코드베이스의 복사본이 있는지를 확인하는 데 사용됩니다. 체크 아웃된 코드를 사용하여 테스트를 실행합니다. 그리고 이 랩에서는 여러 버전을 대상으로 테스트를 수행할 것이므로, **actions/setup-node@v1** 작업을 사용하여 적절한 Node.js 버전을 설정합니다.

    > **참고**: **github/workflows/node.js.yml** 파일의 **on:** 필드는 GitHub Actions에 작업 실행 시기 정보를 제공합니다. 여기서는 푸시가 수신될 때마다 워크플로를 실행합니다.

    > **참고**: **github/workflows/node.js.yml** 파일의 **jobs:** 블록은 Actions 워크플로의 핵심 구성 요소를 정의합니다. 워크플로는 작업으로 구성되며 여기서 사용하는 템플릿 워크플로는 식별자 빌드를 사용하는 작업 하나를 정의합니다. 각 작업에는 작업을 실행할 특정 호스트 머신도 필요합니다. **runs-on:** 필드의 값을 통해 이 머신을 지정합니다. 이 템플릿 워크플로에서는 최신 Ubuntu 버전을 사용하여 빌드 작업을 실행합니다.

    > **참고**: 워크플로는 미리 작성된 작업뿐 아니라 명령도 실행할 수 있습니다. 즉, 빌드를 실행하는 가상 머신에 직접 액세스할 수 있는 경우와 동일한 방식으로 명령을 실행할 수 있습니다. 템플릿 워크플로의 **run:** 필드를 사용하면 프로젝트와 관련된 임의의 명령을 실행할 수 있습니다. 예를 들어 **npm install**을 실행하여 종속성을 설치하거나 **npm test**를 실행하여 선택한 테스트 프레임워크를 실행할 수 있습니다.

    ```yaml
    # 이 워크플로는 노드 종속성을 새로 설치하고 소스 코드를 작성한 다음 여러 노드 버전에서 테스트를 실행합니다.
    # 자세한 내용은 https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions를 참조하세요.

    name: Node.js CI

    on:
      push:
        branches: [ master ]
      pull_request:
        branches: [ master ]

    jobs:
      build:

        runs-on: ubuntu-latest

        strategy:
          matrix:
            node-version: [10.x, 12.x, 14.x]

        steps:
        - uses: actions/checkout@v2
        - name: Use Node.js ${{ matrix.node-version }}
          uses: actions/setup-node@v1
          with:
            node-version: ${{ matrix.node-version }}
        - run: npm ci
        - run: npm run build --if-present
        - run: npm test
    ```

> **참고**: 이 워크플로는 실패합니다. 이러한 결과는 정상적인 현상이므로 무시하세요. 실패의 원인을 파악하려는 경우 리포지토리의 **작업** 탭 내용을 검토할 수도 있고, 끌어오기 요청 **대화** 탭에 나와 있는 실패 관련 **세부 정보** 링크를 클릭할 수도 있습니다.

> **참고**: 여기서는 **npm test** 명령에서 오류가 발생합니다. **npm test** 명령은 테스트 프레임워크를 찾습니다. 여기서는 Jest를 사용합니다. Jest를 사용하려면 [\_\_test\_\_] 디렉터리에 단위 테스트가 있어야 합니다. 그런데 이 분기에는 [\_\_test\_\_] 디렉터리가 없습니다.

#### 작업 3: GitHub 워크플로에 jest 테스트 추가

이 작업에서는 이전 작업에서 확인한 오류를 해결하기 위해 GitHub 워크플로에 Jest 기반 테스트를 추가합니다. 이렇게 하려면 다음 단계를 수행합니다.

- 열려 있는 끌어오기 요청 **Jest 테스트 추가**로 이동합니다.
- 끌어오기 요청을 병합합니다.

1.  **github-actions-for-ci** GitHub 리포지토리의 **Node용 CI 2** 페이지에서 **끌어오기 요청** 탭을 클릭합니다.
1.  끌어오기 요청 목록에서 **Jest 테스트 추가**를 클릭합니다.
1.  **Jest 테스트 추가** 페이지에서 끌어오기 요청의 **대화** 탭 내용을 검토합니다.

    > **참고**: 이 끌어오기 요청에는 널리 사용되고 있는 JavaScript 테스트 프레임워크인 Jest가 포함되어 있습니다. 여기서는 연속 통합에 Jest를 사용하는 방법을 알아봅니다.

1.  **Jest 테스트 추가** 페이지의 해당 끌어오기 요청 **대화** 탭에서 **끌어오기 요청 병합**을 클릭한 다음 **병합 확인**을 클릭합니다.
1.  **Jest 테스트 추가** 페이지의 해당 끌어오기 요청 **대화** 탭에 표시된 **github-learning-lab** 봇의 설명에서 **다음 단계** 링크를 클릭합니다. 그러면 **github-actions-for-ci** GitHub 리포지토리의 **Node용 CI 2** 끌어오기 요청 **대화** 탭으로 다시 리디렉션됩니다.

#### 작업 4: Actions 로그를 검토하여 실패한 테스트 확인

이 작업에서는 Actions 로그를 검토하여 실패하는 테스트를 확인합니다. 

> **참고**: 테스트 프레임워크가 적절하게 구성되었으므로 빌드 프로세스에서 해당 프레임워크를 자동으로 호출해야 합니다. 여기서는 해당 로그를 검토하여 호출 결과를 확인하고 다음 단계를 추천합니다. 앞에서와 마찬가지로 리포지토리의 **작업** 탭을 통해 로그에 액세스할 수도 있고, 끌어오기 요청 **대화** 탭에 나와 있는 실패 관련 **세부 정보** 링크를 클릭할 수도 있습니다.

이 작업을 완료하려면 다음 단계를 순서대로 진행해야 합니다.

- 워크플로 로그로 이동합니다.
- 실패하는 테스트의 이름을 확인합니다.
- 실패하는 테스트 이름이 포함된 설명을 대화에 추가합니다.

1.  **github-actions-for-ci** GitHub 리포지토리의 **Node용 CI 2** 끌어오기 요청 **대화** 탭으로 돌아와서 아래쪽으로 스크롤해 **github-learning-lab** 봇의 **테스트 대기 중** 설명으로 스크롤한 다음 해당 내용을 검토합니다.
1.  **대화** 탭에서 아래쪽의 설명 목록으로 스크롤한 다음 실패한 개별 검사 옆의 각 **세부 정보** 링크를 클릭합니다. 그러면 **Node용 CI 2**의 **검사** 탭으로 자동 리디렉션됩니다.
1.  **Node용 CI 2**의 **검사** 탭에서 각 빌드 로그를 검토하여 모든 검사가 **npm 테스트 실행** 중에 실패함을 확인합니다.
1.  **npm 테스트 실행** 단계를 살펴본 다음 **게임** 섹션에서 실패를 나타내는 **X** 표시가 있는 개별 테스트의 이름을 확인합니다.

    ```
    FAIL __test__/game.test.js
      App
        ✕ Contains the compiled JavaScript (8 ms)
      Game
        Game
          ✕ Initializes with two players (3 ms)
          ✓ Initializes with an empty board (1 ms)
          ✕ Starts the game with a random player
        turn
          ✓ Inserts an 'X' into the top center
          ✓ Inserts an 'X' into the top left
        nextPlayer
          ✕ Sets the current player to be whoever it is not (1 ms)
        hasWinner
          ✓ Wins if any row is filled (1 ms)
          ✓ Wins if any column is filled
          ✓ Wins if down-left diagonal is filled (1 ms)
          ✓ Wins if up-right diagonal is filled
    ```

1.  **대화** 탭으로 다시 전환하여 설명 목록 맨 아래로 스크롤합니다. 그런 다음 마지막 설명의 **쓰기** 탭에서 **설명 남기기**를 이전 단계에서 확인한 다음 이름으로 바꾸고 **설명**을 클릭합니다.

    ```
    Initializes with two players
    Starts the game with a random player
    Sets the current player to be whoever it is not
    ```

> **참고**: 그러면 봇의 다른 설명 집합이 이번에는 **실패한 로그 읽기** 설명부터 **대화** 탭에 자동으로 표시됩니다.

#### 작업 5: 실패하는 테스트 수정

이 작업에서는 문제 해결을 위해 테스트 실패의 원인이 되는 파일을 수정합니다.

> **참고**: 실패하는 테스트 중 하나는 Initializes with two players입니다. 로그를 자세히 살펴보면 단위 테스트에서는 두 플레이어의 이름이 Salem과 Nate여야 하는데 Nate 대신 Bananas가 사용되었음을 확인할 수 있습니다.

    ```
      ● Game › Game › Starts the game with a random player

        expect(received).toBe(expected) // Object.is equality

        Expected: "Nate"
        Received: "Bananas"

          39 | 
          40 |       Math.random = () => 0.6
        > 41 |       expect(new Game(p1, p2).player).toBe('Nate')
             |                                       ^
          42 |     })
          43 |   })
          44 | 
    ```

> **참고**: 일반적으로는 테스트 파일 이름을 테스트 대상 코드 파일과 같게 지정하고 .test.js 확장명만 추가하는 방식을 사용합니다. 여기서는 game.test.js의 테스트 결과가 game.js의 문제로 인해 생성된다고 가정할 수 있습니다.

1.  **github-actions-for-ci** GitHub 리포지토리의 **Node용 CI 2** 끌어오기 요청 **대화** 탭에서 **github-learning-lab** 봇의 최신 설명을 찾은 다음 해당 내용을 검토합니다.
1.  설명에서 참조된 코드 변경 내용을 확인하려면 **변경 내용 보기** 단추를 클릭하고 아래쪽으로 스크롤해 **\_\_test\_\_/game.test.js** 파일을 나타내는 섹션을 표시한 다음 제안 변경 내용을 검토합니다.

    ```yaml
    Suggested change 
        this.p2 = 'Bananas'
        this.p2 = p2
    ```

1.  다시 **github-actions-for-ci** GitHub 리포지토리의 **Node용 CI 2** 끌어오기 요청 **대화** 탭으로 이동한 다음 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시합니다. 그런 다음 **제안 커밋**을 클릭하고 팝업 창에서 **변경 내용 커밋**을 클릭합니다.

    > **참고**: 변경 내용을 커밋하면 테스트가 다시 실행되며 이번에는 정상적으로 완료됩니다. 

1.  **github-actions-for-ci** GitHub 리포지토리의 **Node용 CI 2** 끌어오기 요청 **대화** 탭에서 아래쪽으로 스크롤하여 **변경 내용 승인됨** 응답을 표시합니다. 그런 다음 **끌어오기 요청 병합**, **병합 확인**을 차례로 클릭합니다. 
1.  **github-actions-for-ci** GitHub 리포지토리의 **Node용 CI 2** 끌어오기 요청 **대화** 탭에서 **github-learning-lab** 봇의 최신 설명에 포함되어 있는 **다음 단계** 링크를 클릭합니다. 그러면 **전체 팀용 워크플로 4** 페이지가 표시된 **문제** 탭으로 리디렉션됩니다.

#### 작업 6: 다음 단계 검토

이 작업에서는 전체 팀에서 사용 가능하도록 첫 번째 워크플로를 공유할 수 있는 다음 단계를 검토합니다.

> **참고**: 앞에서 CI 설정 방법을 살펴보았으므로 이번에는 좀 더 현실적인 사용 사례를 수행해 보겠습니다. 팀에서 진행하는 사용자 지정 워크플로에서 지금까지 사용했던 템플릿에서는 제공되지 않는 기능을 사용해야 합니다. 구체적으로는 다음과 같은 기능이 필요합니다.

- 다양한 운영 체제 및 Node.js 버전 조합의 유효성을 검사하기 위해 여러 대상을 테스트하는 기능
- 테스트 세부 정보에서 빌드를 구분할 수 있는 전용 테스트 작업
- 대상 환경에 빌드 아티팩트를 배포하는 데 사용할 수 있는 빌드 아티팩트 액세스 기능
- 마스터 분기를 삭제하거나 실수로 연결을 끊을 수 없도록 설정하는 분기 보호 기능
- 팀원들이 끌어오기 요청을 다시 확인할 수 있는 필수 검토 기능
- 병합을 신속하게 진행하고 필요에 따라 병합과 배포 과정을 자동화할 수 있는 명확한 승인 기능

#### 작업 7: 사용자 지정 GitHub Actions 워크플로 만들기

이 작업에서는 사용자 지정 GitHub Actions 워크플로를 만듭니다.

이 기능을 구현하려면 다음 단계를 순서대로 수행해야 합니다.

- 새 분기에서 기존 워크플로 파일을 편집합니다.
- 워크플로 파일에서 Node 버전 12.x 및 14.x를 대상으로 지정합니다.
- 변경 내용이 포함된 새 끌어오기 요청 **CI 개선**을 엽니다.

1.  **전체 팀용 워크플로 4** 페이지가 표시된 **github-actions-for-ci** 리포지토리의 **문제** 탭에서 아래쪽으로 스크롤하여 레이블이 **7단계: 사용자 지정 GitHub Actions 워크플로 만들기**인 섹션을 표시합니다. 그런 다음 **활동: 새 빌드 대상을 사용하여 기존 워크플로 편집** 목록에서 **기존 워크플로** 링크를 클릭합니다. 그러면 **github-actions-for-ci** 리포지토리 **코드** 탭의 **github-actions-for-ci/.github/workflows/node.js.yml** 파일 **파일 편집** 보기로 리디렉션됩니다.
1.  **github-actions-for-ci/.github/workflows/node.js.yml** 파일에서 `node-version: [10.x, 12.x, 14.x]`를 `node-version: [12.x, 14.x]`로 바꿉니다.
1.  **github-actions-for-ci** 리포지토리 **코드** 탭 오른쪽 위의 **커밋 시작**을 클릭합니다.
1.  **변경 내용 커밋** 창에서 기본 설정을 그대로 적용합니다. 그러면 이 커밋용으로 새 분기가 작성되며 끌어오기 요청이 시작됩니다. **변경 내용 커밋**을 클릭합니다.
1.  **끌어오기 요청 만들기** 페이지에서 끌어오기 요청 이름을 **node.js.yml 업데이트**에서 **CI 개선**으로 바꾸고 **끌어오기 요청 만들기**를 클릭합니다. 그러면 **github-actions-for-ci** 리포지토리 **끌어오기 요청** 탭의 **CI 만들기 5** 페이지로 자동 리디렉션됩니다.

> **참고**: 특정 Node 버전을 대상으로 지정하면 여러 운영 체제, 플랫폼 및 언어 버전을 테스트할 수 있는 빌드 행렬이 구성됩니다. 이 토픽에 대한 자세한 내용을 확인하려는 경우 [GitHub Docs](https://help.github.com/en/articles/configuring-a-workflow#configuring-a-build-matrix)를 참조할 수 있습니다.

#### 작업 8: Windows 환경을 대상으로 지정

이 작업에서는 Windows 환경용 빌드에 사용할 수 있도록 워크플로 파일을 편집합니다.

> **참고**: 여기서는 Windows 환경에 앱을 배포할 수 있도록 설정할 것이므로 행렬 빌드 구성에 Windows를 추가합니다.

이 기능을 구현하려면 다음 단계를 순서대로 수행해야 합니다.

- 워크플로의 **strategy.matrix** 섹션에 **os** 필드를 추가합니다.
- 대상 운영 체제 목록에 **ubuntu-latest** 및 **windows-2016**을 추가합니다.
- 기존 분기로 워크플로 변경 내용을 커밋합니다.

    ```yaml
    node-version: [10.x, 14.x]
    os: [ubuntu-latest, windows-2016]
    node-version: [12.x, 14.x]
    ```

1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **CI 개선 5** 페이지에서 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시한 다음 해당 내용을 검토합니다.
1.  **활동: Windows 환경용 빌드에 사용할 수 있도록 워크플로 파일 편집** 섹션에서 1단계의 **github/workflows/nodejs.yml** 링크를 클릭합니다.  그러면 **github-actions-for-ci** 리포지토리 코드 탭의 **github-actions-for-ci/.github/workflows/node.js.yml** 파일 **파일 편집** 보기로 리디렉션됩니다.
1.  **github-actions-for-ci/.github/workflows/node.js.yml** 파일에서 행렬 섹션을 검토하여 수행해야 하는 변경 작업을 파악합니다. 
1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **CI 개선 5** 페이지에 있는 **활동:** **Windows 환경용 빌드에 사용할 수 있도록 워크플로 파일 편집** 섹션으로 다시 이동하여 **제안 커밋**을 클릭한 다음 팝업 창에서 **변경 내용 커밋**을 클릭합니다.
1.  그러면 **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **CI 개선 5** 페이지의 내용이 **github-learning-lab** 봇의 최신 설명(레이블: **새 작업**)을 반영하여 업데이트됩니다.

> **참고**: 이 시점에 로그를 검토하면 빌드가 4개임을 확인할 수 있습니다. 운영 체제 2개의 2개 버전에 대해 테스트를 실행하기 때문입니다.

#### 작업 9: 여러 작업 구성

이 작업에서는 워크플로 파일을 편집하여 빌드 작업과 테스트 작업을 분리합니다.

> **참고**: 먼저 전용 테스트 작업을 만들겠습니다. 이 작업을 만들면 워크플로의 빌드 기능과 테스트 기능을 여러 작업으로 분리할 수 있습니다. 워크플로를 트리거하면 이러한 작업이 실행됩니다.

1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **CI 개선 5** 페이지에 표시된 **github-learning-lab** 봇의 최신 설명(레이블: **새 작업**)에서 **9단계: 여러 작업 사용** 섹션의 1단계에 나와 있는 **워크플로 파일** 링크를 클릭합니다.  그러면 브라우저가 **github-actions-for-ci** 리포지토리 **코드** 탭의 **github-actions-for-ci/.github/workflows/node.js.yml** 파일 **파일 편집** 보기로 리디렉션됩니다.
1.  빌드 작업 섹션에서 기존 워크플로를 나타내는 다음 내용을 추가합니다.

    ```yaml
    build:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v2
        - name: npm install and build webpack
          run: |
            npm install
            npm run build
    ```

1.  **github-actions-for-ci/.github/workflows/node.js.yml** 파일 맨 아래에 **test** 작업을 나타내는 새 항목을 추가합니다. 들여쓰기가 **build** 작업 항목과 일치해야 합니다. 새 항목의 내용은 다음과 같습니다.

    ```yaml
    test:
      runs-on: ubuntu-latest
      strategy:
        matrix:
          os: [ubuntu-latest, windows-2016]
          node-version: [12.x, 14.x]
      steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}
      - name: npm install, and test
        run: |
          npm install
          npm test
        env:
          CI: true
    ```

1.  그러면 다음 콘텐츠가 반환됩니다.

    ```yaml
    name: Node CI

    on: [push]

    jobs:
      build:

        runs-on: ubuntu-latest

        steps:
          - uses: actions/checkout@v2
          - name: npm install and build webpack
            run: |
              npm install
              npm run build

      test:

        runs-on: ubuntu-latest

        strategy:
          matrix:
            os: [ubuntu-latest, windows-2016]
            node-version: [12.x, 14.x]

        steps:
        - uses: actions/checkout@v2
        - name: Use Node.js ${{ matrix.node-version }}
          uses: actions/setup-node@v1
          with:
            node-version: ${{ matrix.node-version }}
        - name: npm install, and test
          run: |
            npm install
            npm test
          env:
            CI: true
    ```

1.  편집 중인 **github-actions-for-ci/.github/workflows/node.js.yml** 파일의 내용이 표시된 **github-actions-for-ci** 리포지토리 **코드** 탭 오른쪽 위의 **커밋 시작**을 클릭합니다.
1.  **변경 내용 커밋** 창에서 기본 설정을 그대로 적용합니다. 그러면 현재 분기에 변경 내용이 직접 커밋됩니다. **변경 내용 커밋**을 클릭합니다.

> **참고**: 이 커밋이 완료되면 워크플로가 다시 실행됩니다. 

#### 작업 10: 여러 작업 실행
 
이 작업에서는 워크플로의 여러 작업 결과가 반환되기를 기다립니다.

> **참고**: 여기서는 별도로 수행해야 하는 작업이 없습니다. 

#### 작업 11: 작업의 빌드 아티팩트 업로드

이 작업에서는 워크플로 파일의 업로드 작업을 사용하여 작업의 빌드 아티팩트를 저장합니다.

> **참고**: 빌드는 성공했는데 각 테스트 작업은 실패했음을 확인할 수 있습니다. 각 작업은 가상 환경의 새 인스턴스에서 실행되므로 빌드에서 작성된 빌드 아티팩트를 테스트 작업에 사용할 수 없기 때문입니다. 이러한 방식은 가상 환경의 디자인에 따른 기본적인 현상입니다. 이 문제를 해결하려는 경우 기본 제공 아티팩트 스토리지를 사용해 특정 작업에서 작성한 아티팩트를 동일 워크플로 내의 다른 작업에서 사용할 수 있도록 저장하면 됩니다. 이와 같이 아티팩트를 저장하면 작업이 완료된 후에도 데이터를 영구 보존할 수 있으며, 동일 워크플로의 다른 작업과 해당 데이터를 공유할 수 있습니다. 아티팩트는 워크플로 실행 중에 생성되는 파일 또는 파일 컬렉션입니다.

> **참고**: 아티팩트 스토리지에 아티팩트를 업로드하려는 경우 GitHub에서 작성한 작업인 actions/upload-artifacts를 사용할 수 있습니다.

1.  다시 **github-actions-for-ci** GitHub 리포지토리의 **CI 개선 5** 페이지 **끌어오기 요청** 탭으로 이동합니다. 그런 다음 **대화** 탭에서 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시한 후 해당 내용을 검토합니다.
1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **CI 개선 5** 페이지에 표시된 **github-learning-lab** 봇의 최신 설명(레이블: **새 작업**)에서 **11단계: 작업의 빌드 아티팩트 업로드** 섹션의 1단계에 나와 있는 **워크플로 파일** 링크를 클릭합니다. 그러면 브라우저가 **github-actions-for-ci** 리포지토리 **코드** 탭의 **github-actions-for-ci/.github/workflows/node.js.yml** 파일 **파일 편집** 보기로 리디렉션됩니다.
1.  빌드 작업 섹션에서 다음 내용과 일치하도록 **upload-artifacts** 작업을 포함하여 빌드 작업을 업데이트합니다.

    ```yaml
      build:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v2
          - name: npm install and build webpack
            run: |
              npm install
              npm run build
          - uses: actions/upload-artifact@master
            with:
              name: webpack artifacts
              path: public/
    ```

1.  편집 중인 **github-actions-for-ci/.github/workflows/node.js.yml** 파일의 내용이 표시된 **github-actions-for-ci** 리포지토리 **코드** 탭 오른쪽 위의 **커밋 시작**을 클릭합니다.
1.  **변경 내용 커밋** 창에서 기본 설정을 그대로 적용합니다. 그러면 현재 분기에 변경 내용이 직접 커밋됩니다. **변경 내용 커밋**을 클릭합니다.

> **참고**: 이 커밋이 완료되면 워크플로가 다시 실행됩니다. 

#### 작업 12: 작업의 빌드 아티팩트 다운로드

이 작업에서는 워크플로 파일의 다운로드 작업을 사용하여 이전 작업의 빌드 아티팩트에 액세스합니다.

> **참고**: 이제 빌드 아티팩트는 아티팩트 스토리지에 업로드되었지만 워크플로를 추적해 보면 테스트 작업은 여전히 실패함을 확인할 수 있습니다. 테스트가 실패하는 기본적인 이유는 다음의 두 가지입니다.

- 작업이 순차적으로 실행되도록 명시적으로 구성하지 않으면 병렬로 실행됩니다.
- 각 작업이 자체 가상 환경에서 실행되므로 아티팩트를 스토리지에 푸시했지만 테스트 작업이 해당 아티팩트를 검색해야 합니다.

> **참고**: 이 문제를 해결하려면 아티팩트를 사용할 수 있도록 빌드가 완료된 후에만 테스트를 실행합니다. 그리고 지정된 아티팩트 저장소에 아티팩트를 복사하는 업로드 작업을 활용하기 위해 또 다른 GitHub 기본 제공 작업인 **actions/download-artifact**를 사용하여 이러한 아티팩트를 다운로드합니다.

1.  다시 **github-actions-for-ci** GitHub 리포지토리의 **CI 개선 5** 페이지 **끌어오기 요청** 탭으로 이동합니다. 그런 다음 **대화** 탭에서 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시한 후 해당 내용을 검토합니다.
1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **CI 개선 5** 페이지에 표시된 **github-learning-lab** 봇의 최신 설명(레이블: **새 작업**)에서 **12단계: 작업의 빌드 아티팩트 다운로드** 섹션의 1단계에 나와 있는 **워크플로 파일** 링크를 클릭합니다. 그러면 브라우저가 **github-actions-for-ci** 리포지토리 **코드** 탭의 **github-actions-for-ci/.github/workflows/node.js.yml** 파일 **파일 편집** 보기로 리디렉션됩니다.
1. 테스트 작업 섹션에서 다음 내용과 일치하도록 **needs: build** 구성 요소를 추가하여 빌드 작업이 완료된 후에만 테스트 작업이 실행되도록 업데이트합니다.

    ```yaml
    test:
      needs: build
      runs-on: ubuntu-latest
    ```

1.  빌드 작업 섹션에서 다음 내용과 일치하도록 **download-artifacts** 작업을 포함하여 빌드 작업을 업데이트합니다.

    ```yaml
    steps:
    - uses: actions/checkout@v2
    - uses: actions/download-artifact@master
      with: 
        name: webpack artifacts
        path: public
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v1
      with:
        node-version: ${{ matrix.node-version }}
    - name: npm install, and test
      run: |
        npm install
        npm test
      env:
        CI: true
    ```

1.  편집 중인 **github-actions-for-ci/.github/workflows/node.js.yml** 파일의 내용이 표시된 **github-actions-for-ci** 리포지토리 **코드** 탭 오른쪽 위의 **커밋 시작**을 클릭합니다.
1.  **변경 내용 커밋** 창에서 기본 설정을 그대로 적용합니다. 그러면 현재 분기에 변경 내용이 직접 커밋됩니다. **변경 내용 커밋**을 클릭합니다.

> **참고**: 이 커밋이 완료되면 워크플로가 다시 실행됩니다. 

> **참고**: 이제 사용자 지정 워크플로에서 다음 기능을 제공합니다.

- 여러 대상을 테스트하여 지원되는 운영 체제 및 Node.js 버전이 작동하는지 확인하는 기능
- 테스트 세부 정보에서 빌드를 구분할 수 있는 전용 테스트 작업
- 대상 환경에 빌드 아티팩트를 배포하는 데 사용할 수 있는 빌드 아티팩트 액세스 기능

#### 작업 13: 팀과 개선된 CI 워크플로 공유

이 작업에서는 끌어오기 요청과 개선된 워크플로를 마스터 분기에 병합합니다.

1.  다시 **github-actions-for-ci** GitHub 리포지토리의 **CI 개선 5** 페이지 **끌어오기 요청** 탭으로 이동합니다. 그런 다음 **대화** 탭에서 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시한 후 해당 내용을 검토합니다.
1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **CI 개선 5** 페이지에 표시된 **github-learning-lab** 봇의 최신 설명(레이블: **CI 병합**)에서 **13단계: 팀과 개선된 CI 워크플로 공유** 섹션의 내용을 검토합니다.

    > **참고**: 지금까지 구현한 요구 사항 목록의 상태는 다음과 같습니다.

    - 여러 대상을 테스트하여 지원되는 운영 체제 및 Node.js 버전이 작동하는지 확인
    - 테스트 세부 정보에서 빌드를 구분할 수 있는 전용 테스트 작업
    - 대상 환경에 빌드 아티팩트를 배포하는 데 사용할 수 있는 빌드 아티팩트 액세스 기능

    > **참고**: 다음에 수행할 몇 단계에서는 팀 워크플로에 다음 기능을 제공하도록 변경을 수행합니다.

    - 마스터 분기를 삭제하거나 실수로 연결을 끊을 수 없도록 설정하는 분기 보호 기능
    - 팀원들이 끌어오기 요청을 다시 확인할 수 있는 필수 검토 기능
    - 병합을 신속하게 진행하고 필요에 따라 병합과 배포 과정을 자동화할 수 있는 명확한 승인 기능

1.  아래쪽의 **변경 내용 승인됨** 섹션으로 스크롤하여 **끌어오기 요청 병합**을 클릭한 다음 **병합 확인**을 클릭합니다.

#### 작업 14: 검토 프로세스 자동화

이 작업에서는 팀의 검토 프로세스 자동화를 위해 새 워크플로 파일을 추가합니다.

1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **CI 개선 5** 페이지에 표시된 **github-learning-lab** 봇의 최신 설명에서 **다음 단계** 링크를 클릭합니다. 그러면 **사용자 지정 워크플로 6** 끌어오기 요청의 **대화** 탭으로 리디렉션됩니다.
1.  **사용자 지정 워크플로 6** 끌어오기 요청의 **대화** 탭에서 아래쪽으로 스크롤하여 레이블이 **14단계: 검토 프로세스 자동화**인 섹션의 내용을 검토합니다.

    > **참고**: GitHub Actions는 각 이벤트 트리거에 해당하는 여러 워크플로를 실행할 수 있습니다. 여기서는 Node.js 워크플로와 함께 사용할 새 승인 워크플로를 만들어 보겠습니다.

1.  레이블이 **활동: 팀의 검토 프로세스 자동화를 위해 새 워크플로 파일 추가**인 섹션의 작업 목록에서 1단계의 **새 파일** 링크를 클릭합니다. 그러면 **github-actions-for-ci** 리포지토리 **코드** 탭으로 리디렉션되며 **github-actions-for-ci/.github/workflows/approval-workflow.yml** 파일이 열려 있는 편집기 페이지가 표시됩니다.
1.  편집기 창 내에서 `name: AZ-400 Team approval workflow`를 입력하고 페이지 아래쪽으로 스크롤한 다음 **새 파일 커밋**을 클릭합니다.

#### 작업 15: 작업을 사용하여 끌어오기 요청 검토 자동화

이 작업에서는 새 워크플로에서 커뮤니티 작업을 사용합니다.

> **참고**: 워크플로는 다음과 같이 실행되도록 구성할 수 있습니다.

- GitHub의 이벤트를 사용하여 실행
- 예약된 시간에 실행
- GitHub 외부에서 이벤트가 발생하면 실행

> **참고**: 앞에서는 Node.js 워크플로에 푸시 이벤트를 사용했습니다. 리포지토리에서 코드가 변경될 때 작업을 수행하려는 경우에는 이러한 이벤트를 사용하면 됩니다. 그런데 검토 워크플로에서는 실제 검토자가 검토를 진행하려고 합니다. 예를 들어 검토를 충분히 수행했으므로 끌어오기 요청을 병합해도 되는 시점을 쉽게 파악할 수 있도록 '승인된 끌어오기 요청 작업'이라는 레이블을 사용하려고 합니다. 그러면 검토 워크플로 준비를 위해 **pull_request_review** 이벤트를 사용하여 검토 워크플로를 트리거하겠습니다.

1.  다시 **사용자 지정 워크플로 6** 끌어오기 요청의 **대화** 탭으로 이동합니다. 그런 다음 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시한 후 해당 내용을 검토합니다.
1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭에서 레이블이 **사용자 지정 워크플로 6**인 페이지에 표시된 **github-learning-lab** 봇의 최신 설명에서 **15단계: 작업을 사용하여 끌어오기 요청 검토 자동화** 섹션의 내용을 검토합니다.
1.  이 단계에서는 이전 단계에서 만든 워크플로 파일에 **on: pull_request_review**만 추가합니다.
1.  **15단계: 작업을 사용하여 끌어오기 요청 검토 자동화** 섹션 내에서 **제안 커밋**을 클릭하고 팝업 창에서 **변경 내용 커밋**을 클릭합니다.

#### 작업 16: 새 워크플로에서 승인 작업 만들기

이 작업에서는 새 워크플로 파일에 커뮤니티 작업을 사용할 새 작업을 만듭니다.

1.  **사용자 지정 워크플로 6** 끌어오기 요청의 **대화** 탭에서 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시한 후 해당 내용을 검토합니다.
1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **사용자 지정 워크플로 6** 페이지에 표시된 **github-learning-lab** 봇의 최신 설명에서 **16단계: 새 워크플로에서 승인 작업 만들기** 섹션의 내용을 검토합니다.
1.  이 단계에서는 이전 작업에서 수정한 것과 같은 워크플로 파일에 새 작업 **labelWhenApproved**를 다음 형식으로 추가합니다.

    ```yaml
    jobs:
      labelWhenApproved:
        runs-on: ubuntu-latest
    ```

1.  **16단계: 새 워크플로에서 승인 작업 만들기** 섹션 내에서 **제안 커밋**을 클릭하고 팝업 창에서 **변경 내용 커밋**을 클릭합니다.

#### 작업 17: 승인 자동화

이 작업에서는 커뮤니티 작업을 사용하여 검토 승인 프로세스 부분을 자동화합니다.

> **참고**: 이전 작업에서는 식별자가 **labelWhenApproved**인 작업을 만들었습니다. 이번에는 커뮤니티에서 만든 **pullreminders/label-when-approved-action** 작업을 사용하겠습니다. 이 작업은 승인이 미리 설정된 횟수만큼 완료되면 모든 끌어오기 요청에 레이블을 추가합니다. 이러한 레이블은 병합 가능한 항목이 있음을 팀에 알려 주는 시각적 표시기로 사용할 수 있습니다. 다른 도구나 작업을 사용하여 필요한 횟수만큼 승인이 되면 끌어오기 요청을 자동 병합할 때도 이러한 레이블을 사용할 수도 있습니다.

1.  사용자 지정 워크플로 6 끌어오기 요청의 대화 탭에서 아래쪽으로 스크롤하여 github-learning-lab 봇의 최신 설명을 표시한 후 해당 내용을 검토합니다.
1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭 **사용자 지정 워크플로 6** 페이지에 표시된 **github-learning-lab** 봇의 최신 설명에서 **17단계: 승인 자동화** 섹션의 내용을 검토합니다.

    > **참고**: 이 작업을 구현하려면 다음 지침을 따르세요.

    - 워크플로 파일에는 **steps:** 블록이 필요합니다.
    - 단계 이름은 임의로 지정됩니다.
    - 커뮤니티 작업을 사용하려면 **uses:** 키워드를 포함합니다.
    - **label-when-approved-action**을 사용하려면 다음 환경 변수가 포함된 **env:** 블록을 추가해야 합니다.
       - **APPROVALS**: 레이블을 적용하려면 필요한 승인 횟수입니다. 이 랩에서는 **1**로 설정합니다.
       - **GITHUB_TOKEN**: 작업이 레이블을 만들어 이 리포지토리에 적용하려면 필요한 변수입니다. 
       - **ADD_LABEL**: 필요한 횟수만큼 승인을 받으면 추가해야 하는 레이블의 이름입니다. 이 이름은 임의로 지정됩니다.

1.  **github-actions-for-ci** 리포지토리의 **코드** 탭으로 전환하여 분기 목록에서 **team-workflow** 항목을 선택하고 폴더 목록에서는 **github/workflows**를, 파일 목록에서는 **approval-workflow.yml**을 클릭합니다. 그리고 **github-actions-for-ci/.github/workflows/approval-workflow.yml**의 내용을 확인하면서 코드 창 오른쪽의 연필 아이콘을 클릭하여 편집 모드로 전환합니다.
1.  **approval-workflow.yml** 파일에 다음 내용을 추가합니다.

    ```yaml
    steps:
    - name: Label when approved
      uses: pullreminders/label-when-approved-action@master
      env:
        APPROVALS: "1"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        ADD_LABEL: "approved"
    ```

1.  **커밋 시작**을 클릭합니다.
1.  **변경 내용 커밋** 창에서 기본 설정을 그대로 적용합니다. 그러면 현재 분기에 변경 내용이 직접 커밋됩니다. **변경 내용 커밋**을 클릭합니다.

#### 작업 18: 분기 보호 기능 사용

이 작업에서는 마스터 분기를 보호하는 것으로 자동화된 검토 프로세스를 완료합니다.

> **참고**: 분기를 보호하면 리포지토리의 공동 작업자들이 분기에서 취소 불가능한 변경 작업을 수행할 수 없게 됩니다. 그리고 보호된 분기를 사용하도록 설정하면 필수 상태 확인 및 검토와 같은 기타 선택적 확인과 요구 사항도 사용할 수 있습니다.

1.  다시 **사용자 지정 워크플로 6** 끌어오기 요청의 **대화** 탭으로 이동합니다. 그런 다음 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시한 후 해당 내용을 검토합니다.
1.  **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭에서 레이블이 **사용자 지정 워크플로 6**인 페이지에 표시된 **github-learning-lab** 봇의 최신 설명에서 **18단계: 분기 보호 기능 사용** 섹션의 내용을 검토합니다.
1.  페이지 위쪽으로 다시 스크롤하여 위쪽 메뉴에서 **설정** 머리글을 클릭하고 왼쪽의 세로 메뉴에서 **분기**를 클릭합니다.
1.  **분기 보호 규칙** 섹션에서 **규칙 추가**를 클릭합니다.
1.  **분기 보호 규칙**의 **분기 이름 패턴**에 **마스터**를 입력하고 **일치하는 분기 보호** 설정 목록에서 **병합 전에 끌어오기 요청 검토 필요** 및 **병합 전에 상태 확인을 통과해야 함**을 사용하도록 설정합니다. 그런 다음 각 빌드 작업과 테스트 작업 옆의 체크박스를 선택하고 페이지 아래쪽으로 스크롤하여 **만들기**를 클릭합니다.
1.  다시 **사용자 지정 워크플로 6** 끌어오기 요청의 **대화** 탭으로 이동합니다. 그런 다음 아래쪽으로 스크롤하여 **github-learning-lab** 봇의 최신 설명을 표시한 후 **18단계: 분기 보호 기능 사용** 섹션의 내용을 검토하고 **활동: 마스터 분기를 보호하는 것으로 자동화된 검토 프로세스 완료** 하위 섹션의 8단계에서 **요청한 검토 승인** 링크를 클릭합니다. 그러면 브라우저 세션이 **사용자 지정 워크플로** 끌어오기 요청의 **파일 변경됨** 탭으로 리디렉션됩니다.
1.  **사용자 지정 워크플로** 끌어오기 요청의 **파일 변경됨** 탭에서 **변경 내용 검토**를 클릭하고 **승인** 옵션을 선택한 후에 **검토 제출**을 클릭합니다. 그러면 브라우저 세션이 **github-actions-for-ci** 리포지토리의 **끌어오기 요청** 탭에서 레이블이 **사용자 지정 워크플로 6**인 페이지로 다시 리디렉션됩니다. 이 페이지에 표시된 **github-learning-lab** 봇의 최신 설명에는 워크플로가 정상적으로 완료되었음을 확인하는 내용이 포함되어 있습니다.

## 복습

이 랩에서는 빌드 프로세스를 자동화하는 GitHub 워크플로를 설정하는 방법을 배웠습니다.